1. The User Collection (Primary Schema)

Each entry in your database (represented by the "User 1" box) should revolve around the WhatsApp Number as the unique identifier.
Field	Type	Description
waNumber	String (PK)	The unique ID (Phone number). Used for the "New Sender?" check.
profileName	String	The display name pulled from the WhatsApp metadata.
lastInteraction	Timestamp	Useful for tracking when to trigger the "Summarization" logic.
summary	String	Stores the condensed history from your "Cheaper Model" to save space.
waMSG	Array/Object	The raw conversation log (JSON).


2. The waMSG Structure (Conversation Log)

In your drawing, you show a nested structure. To make this compatible with AI models (which typically expect a "role" and "content" format), your schema for this field should look like this:
JSON

"waMSG": [
  {
    "role": "user",
    "content": "hi",
    "timestamp": "2025-10-01T10:00:00Z"
  },
  {
    "role": "bot",
    "content": "hello, welcome....",
    "timestamp": "2025-10-01T10:00:05Z"
  }
]


3. How the Schema Supports Your Logic

Your diagram highlights two specific flows that the DB schema must handle:

    The "New Sender" Check: When a message hits the Backend API, it queries the DB: SELECT * FROM users WHERE waNumber = '12345'. If null, the schema initializes a new record with the profileName.

    The Summarization Trigger: Your schema needs a way to distinguish between "Full History" and "Summary."

        Phase A: The waMSG array grows.

        Phase B: Once a token limit is hit, the Backend sends waMSG to the "Cheaper Model."

        Phase C: The Backend clears (or archives) the waMSG array and updates the summary field.

        Phase D: The next time the user messages, the prompt sent to the AI is: Summary + New Message.

4. Recommended Database Choice
    NEON Serverless PostgreSQL (Relational): If you prefer SQL, you can use a JSONB column for the waMSG field to get the best of both worlds (structured user data + flexible chat logs).